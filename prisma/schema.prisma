generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String? @db.Text
  access_token             String? @db.Text
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String? @db.Text
  session_state            String?
  refresh_token_expires_in Int?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                  String    @id @default(cuid())
  name                String?
  email               String?   @unique
  emailVerified       DateTime?
  image               String?
  calendarConnected   Boolean   @default(false)
  preferences         Json?
  country             String    @default("UK") // For public holiday detection
  bufferMinutes       Int       @default(0) // Buffer time between tasks (0, 15, or 30 min)
  availableTimeStart  Int       @default(6) // Earliest hour for scheduling (0-23, default 6am)
  availableTimeEnd    Int       @default(22) // Latest hour for scheduling (0-23, default 10pm)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  accounts             Account[]
  sessions             Session[]
  tasks                Task[]
  scheduledTasks       ScheduledTask[]
  feedback             Feedback[]
  learningData         LearningData[]
  progress             ProgressTracking[]
  familyMember         FamilyMember?
  externalCalendars    ExternalCalendar[]
  addinTokens          AddinToken[]
  userPreferences      UserPreference[]
  notifications        Notification[]
  weeklyPlanApprovals  WeeklyPlanApproval[]
  onboarding           OnboardingProgress?
  workSchedule         UserWorkSchedule[]
  vacations            UserVacation[]
  reassignmentsFrom    TaskReassignmentLog[] @relation("ReassignedFrom")
  reassignmentsTo      TaskReassignmentLog[] @relation("ReassignedTo")
}

model ExternalCalendar {
  id        String   @id @default(cuid())
  userId    String
  name      String   // e.g., "Work Calendar", "Personal Outlook"
  url       String   @db.Text // ICS/webcal URL
  color     String?  // Optional color for display
  isActive  Boolean  @default(true)
  lastSync  DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, url])
}

model AddinToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  name      String   @default("Outlook Add-in") // Device/app name
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Family {
  id         String   @id @default(cuid())
  name       String
  inviteCode String   @unique
  createdAt  DateTime @default(now())

  members      FamilyMember[]
  tasks        Task[]
  agentMemory  AgentMemory[]
  weeklyPlans  WeeklyPlan[]
}

model FamilyMember {
  id       String @id @default(cuid())
  familyId String
  userId   String @unique
  role     String @default("member") // "admin" or "member"

  family Family @relation(fields: [familyId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Task {
  id                String   @id @default(cuid())
  userId            String?
  familyId          String?
  name              String
  type              String   // "resolution" or "household"
  duration          Int      // in minutes (default/max duration for flexible tasks)
  isFlexible        Boolean  @default(true)
  category          String?
  priority          Int      @default(3) // 1-4, lower is higher priority
  defaultAssigneeId String?  // Learned default assignee for Life Admin tasks (null = creator)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Scheduling mode: "fixed" or "flexible"
  schedulingMode      String   @default("flexible")

  // Fixed schedule settings (for schedulingMode = "fixed")
  fixedDays           String[] // ["monday", "wednesday", "friday"]
  fixedTime           String?  // "15:00" (24hr format)

  // Flexible schedule settings (for schedulingMode = "flexible")
  frequency           Int?     @default(1) // times per period
  frequencyPeriod     String?  @default("week") // "day" or "week"
  requiredDays        String[] // Must be scheduled on one of these days (e.g., class only offered Tue/Thu)
  preferredDays       String[] // Soft preference for these days
  preferredTimeStart  String?  // "17:00" - start of preferred window
  preferredTimeEnd    String?  // "21:00" - end of preferred window
  minDuration         Int?     // Minimum duration in minutes (for flexible duration)
  maxDuration         Int?     // Maximum duration in minutes (for flexible duration)

  user              User?              @relation(fields: [userId], references: [id], onDelete: Cascade)
  family            Family?            @relation(fields: [familyId], references: [id], onDelete: Cascade)
  scheduledTasks    ScheduledTask[]
  conflicts         ScheduleConflict[] @relation("ConflictTask")
  displacedBy       ScheduleConflict[] @relation("DisplacedTask")
  recommendations   AIRecommendation[]
  reassignmentLogs  TaskReassignmentLog[]
}

model ScheduledTask {
  id                  String   @id @default(cuid())
  taskId              String
  assignedToUserId    String
  scheduledDate       DateTime
  startTime           DateTime
  endTime             DateTime
  status              String   @default("pending") // "pending", "completed", "skipped"
  calendarEventId     String?  // Primary calendar (Google) event ID
  workCalendarEventId String?  // Work calendar (M365 via add-in) event ID
  aiReasoning         String?  @db.Text
  createdAt           DateTime @default(now())

  // AI Learning control
  learningEnabled     Boolean  @default(true) // Whether AI should learn from this task's outcome
  outcomeRecordedAt   DateTime? // When the outcome was recorded (for evidence trail)

  // Manual move tracking
  wasManuallyMoved    Boolean  @default(false)
  originalStartTime   DateTime? // Original time before manual move
  originalEndTime     DateTime? // Original end time before manual move
  movedAt             DateTime? // When it was manually moved
  movedBy             String?   // UserId who moved it
  moveReason          String?   // Optional reason for the move

  // Partial overlap tracking (when task is shortened due to conflict)
  wasShortened        Boolean  @default(false)
  originalDuration    Int?     // Original duration before shortening

  // Double-booking tracking (user intentionally scheduled over conflict)
  wasDoubleBooked     Boolean  @default(false)

  task       Task       @relation(fields: [taskId], references: [id], onDelete: Cascade)
  assignedTo User       @relation(fields: [assignedToUserId], references: [id], onDelete: Cascade)
  feedback   Feedback[]

  // Conflicts where this task was moved
  conflictsAsMoved     ScheduleConflict[] @relation("MovedTask")
  // Conflicts where this task was displaced
  conflictsAsDisplaced ScheduleConflict[] @relation("DisplacedScheduledTask")
  // Evidence for learned preferences
  preferenceEvidence   PreferenceEvidence[]
  // Overlap tracking
  overlaps             ScheduleOverlap[]
}

model Feedback {
  id              String   @id @default(cuid())
  scheduledTaskId String
  userId          String

  // Time feedback
  actualDuration  Int?     // How long it actually took (minutes)
  timeAccuracy    String?  // "too_short", "just_right", "too_long"

  // Scheduling feedback
  timeSlotRating  Int?     // 1-5 how good was this time slot
  wouldReschedule String?  // "earlier", "later", "different_day", "no"
  preferredTime   String?  // "morning", "afternoon", "evening", "weekend"

  // Context feedback
  trafficImpact   Boolean? // Was traffic a factor?
  weatherImpact   Boolean? // Was weather a factor?
  energyLevel     String?  // "low", "medium", "high"

  // Free-form
  notes           String?  @db.Text

  createdAt       DateTime @default(now())

  scheduledTask ScheduledTask @relation(fields: [scheduledTaskId], references: [id], onDelete: Cascade)
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model LearningData {
  id                 String   @id @default(cuid())
  userId             String
  taskType           String
  taskCategory       String?
  learnedDuration    Int?
  learnedPreferences Json?
  updatedAt          DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, taskType, taskCategory])
}

model ProgressTracking {
  id             String   @id @default(cuid())
  userId         String
  weekStartDate  DateTime
  taskType       String
  completedCount Int      @default(0)
  totalCount     Int      @default(0)
  achievements   Json?
  createdAt      DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, weekStartDate, taskType])
}

// ============================================
// AI AGENT SYSTEM MODELS
// ============================================

// Store learned user preferences from feedback
model UserPreference {
  id         String   @id @default(cuid())
  userId     String
  key        String   // e.g., "preferred_gym_time", "commute_buffer", "energy_pattern"
  value      Json     // Flexible storage for different preference types
  confidence Float    @default(0.5) // 0-1, how confident the system is in this preference
  source     String   @default("inferred") // "inferred", "explicit", "default"
  isActive   Boolean  @default(true) // For "Forget" functionality - keeps data but disables preference
  updatedAt  DateTime @updatedAt
  createdAt  DateTime @default(now())

  user     User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  evidence PreferenceEvidence[]

  @@unique([userId, key])
}

// Evidence trail for learned preferences
model PreferenceEvidence {
  id               String   @id @default(cuid())
  preferenceId     String
  scheduledTaskId  String
  signalType       String   // "completed", "skipped", "rescheduled"
  signalStrength   Float    @default(1.0) // Weight of this evidence (1.0 = normal, higher = stronger signal)
  taskName         String   // Denormalized for display
  scheduledTime    DateTime // When the task was scheduled
  dayOfWeek        String   // "monday", "tuesday", etc.
  timeOfDay        String   // "morning", "afternoon", "evening"
  createdAt        DateTime @default(now())

  preference    UserPreference @relation(fields: [preferenceId], references: [id], onDelete: Cascade)
  scheduledTask ScheduledTask  @relation(fields: [scheduledTaskId], references: [id], onDelete: Cascade)

  @@index([preferenceId])
  @@index([scheduledTaskId])
}

// Store agent conversation context and decision history
model AgentMemory {
  id        String   @id @default(cuid())
  familyId  String
  agentType String   // "interactive", "weekly_planner", "reminder", "optimizer"
  sessionId String?  // For grouping related interactions
  context   Json     // Stored conversation/decision context
  summary   String?  @db.Text // Human-readable summary of what happened
  expiresAt DateTime
  createdAt DateTime @default(now())

  family Family @relation(fields: [familyId], references: [id], onDelete: Cascade)

  @@index([familyId, agentType])
  @@index([expiresAt])
}

// Weekly Plan - AI-generated schedule drafts for approval
model WeeklyPlan {
  id          String   @id @default(cuid())
  familyId    String
  weekStart   DateTime // Start of the week (Monday)
  weekEnd     DateTime // End of the week (Sunday)
  status      String   @default("draft") // "draft", "pending_approval", "approved", "rejected", "expired"
  aiReasoning String?  @db.Text // Why the AI made these choices
  createdBy   String   @default("system") // "system" for cron, userId for manual
  approvedBy  String?  // Deprecated: use approvals relation instead
  approvedAt  DateTime? // When fully approved (all members)
  rejectedAt  DateTime?
  expiresAt   DateTime // Auto-expire if not acted upon
  createdAt   DateTime @default(now())

  family    Family               @relation(fields: [familyId], references: [id], onDelete: Cascade)
  items     WeeklyPlanItem[]
  approvals WeeklyPlanApproval[]

  @@unique([familyId, weekStart])
  @@index([status, expiresAt])
}

// Track individual member approvals for a weekly plan
model WeeklyPlanApproval {
  id           String   @id @default(cuid())
  weeklyPlanId String
  userId       String
  status       String   @default("pending") // "pending", "approved", "rejected"
  approvedAt   DateTime?
  rejectedAt   DateTime?
  comment      String?  @db.Text // Optional feedback on the plan
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  weeklyPlan WeeklyPlan @relation(fields: [weeklyPlanId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([weeklyPlanId, userId])
  @@index([weeklyPlanId])
}

// Individual items in a weekly plan
model WeeklyPlanItem {
  id               String   @id @default(cuid())
  weeklyPlanId     String
  taskId           String
  assignedToUserId String
  scheduledDate    DateTime
  startTime        DateTime
  endTime          DateTime
  aiReasoning      String?  @db.Text // Why this specific time was chosen
  createdAt        DateTime @default(now())

  // Edit tracking for conflict detection
  version          Int      @default(1)
  lastEditedBy     String?  // userId who last edited
  lastEditedAt     DateTime?
  editHistory      Json?    // Array of previous edits for audit trail

  weeklyPlan WeeklyPlan @relation(fields: [weeklyPlanId], references: [id], onDelete: Cascade)

  @@index([weeklyPlanId])
}

// Track scheduling conflicts introduced by user manual moves
model ScheduleConflict {
  id                    String   @id @default(cuid())
  userId                String   // User who caused the conflict
  weekOf                DateTime // Start of week for reporting

  // The task that was moved
  movedScheduledTaskId  String
  movedTaskId           String

  // The task that was displaced/affected (null if just shortened)
  displacedScheduledTaskId String?
  displacedTaskId       String?

  // Timing details
  originalStartTime     DateTime
  originalEndTime       DateTime
  newStartTime          DateTime
  newEndTime            DateTime

  // What happened to the displaced task
  resolutionType        String   // "displaced", "shortened", "overlapping"
  displacedTaskNewStart DateTime?
  displacedTaskNewEnd   DateTime?

  // User interaction
  userAccepted          Boolean  @default(true) // User acknowledged the conflict
  createdAt             DateTime @default(now())

  movedScheduledTask    ScheduledTask  @relation("MovedTask", fields: [movedScheduledTaskId], references: [id], onDelete: Cascade)
  movedTask             Task           @relation("ConflictTask", fields: [movedTaskId], references: [id], onDelete: Cascade)
  displacedScheduledTask ScheduledTask? @relation("DisplacedScheduledTask", fields: [displacedScheduledTaskId], references: [id], onDelete: SetNull)
  displacedTask         Task?          @relation("DisplacedTask", fields: [displacedTaskId], references: [id], onDelete: SetNull)

  @@index([userId, weekOf])
  @@index([movedTaskId])
}

// AI-generated recommendations based on conflict patterns
model AIRecommendation {
  id              String   @id @default(cuid())
  userId          String
  taskId          String?  // Related task (if applicable)

  type            String   // "reschedule", "reduce_frequency", "change_time", "change_days", "general"
  reason          String   @db.Text // "You rescheduled Gym 4 times last week"
  suggestion      String   @db.Text // Human-readable suggestion
  suggestedChange Json?    // Structured change data

  // For display context
  priority        String   @default("normal") // "low", "normal", "high"
  displayLocation String   @default("weekly_plan") // "weekly_plan", "tasks", "insights", "dashboard"

  status          String   @default("pending") // "pending", "accepted", "dismissed", "expired"
  respondedAt     DateTime?
  expiresAt       DateTime?
  createdAt       DateTime @default(now())

  task Task? @relation(fields: [taskId], references: [id], onDelete: SetNull)

  @@index([userId, status])
  @@index([displayLocation, status])
}

// Notification queue for reminders and agent messages
// Onboarding progress tracking
model OnboardingProgress {
  id                      String    @id @default(cuid())
  userId                  String    @unique
  calendarConnected       Boolean   @default(false)
  firstTaskCreated        Boolean   @default(false)
  firstScheduleGenerated  Boolean   @default(false)
  firstFeedbackGiven      Boolean   @default(false)
  skippedAt               DateTime? // When user clicked "skip for now"
  completedAt             DateTime? // When all steps were completed
  currentStep             Int       @default(1) // 1-4 for progress tracking
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Notification {
  id           String    @id @default(cuid())
  userId       String
  type         String    // "reminder", "suggestion", "weekly_plan", "conflict", "achievement"
  title        String
  message      String    @db.Text
  actionUrl    String?   // Deep link to relevant page
  actionLabel  String?   // Button text like "View Schedule"
  priority     String    @default("normal") // "low", "normal", "high", "urgent"
  metadata     Json?     // Additional data for the notification
  scheduledFor DateTime  // When to show/send the notification
  sentAt       DateTime? // When it was actually sent
  readAt       DateTime? // When user read it
  dismissedAt  DateTime? // When user dismissed it
  createdAt    DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, scheduledFor])
  @@index([userId, readAt])
}

// Track schedule overlaps/conflicts for health metrics
model ScheduleOverlap {
  id               String    @id @default(cuid())
  userId           String
  scheduledTaskId  String?   // Our scheduled task (if applicable)
  calendarEventId  String?   // External calendar event ID
  overlapsWith     String?   // Description of what it overlaps with
  overlapMinutes   Int       // Duration of overlap in minutes
  userAccepted     Boolean   @default(false) // User acknowledged and scheduled anyway
  weekOf           DateTime  // For weekly reporting
  createdAt        DateTime  @default(now())

  scheduledTask ScheduledTask? @relation(fields: [scheduledTaskId], references: [id], onDelete: SetNull)

  @@index([userId, weekOf])
}

// ============================================
// WORK SCHEDULE & AVAILABILITY MODELS
// ============================================

// Per-day work schedule configuration
model UserWorkSchedule {
  id           String   @id @default(cuid())
  userId       String
  dayOfWeek    String   // "monday", "tuesday", etc.
  isWorking    Boolean  @default(true)
  startTime    String?  // "09:00" (24hr format)
  endTime      String?  // "17:00" (24hr format)
  location     String   @default("home") // "home", "office"
  commuteToMin Int?     // Commute time to office in minutes
  commuteFromMin Int?   // Commute time from office in minutes
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, dayOfWeek])
  @@index([userId])
}

// User vacation/time-off periods
model UserVacation {
  id        String   @id @default(cuid())
  userId    String
  startDate DateTime
  endDate   DateTime
  note      String?  // Optional note like "Work trip", "Holiday"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, startDate, endDate])
}

// Track task reassignments for learning default assignee
model TaskReassignmentLog {
  id             String   @id @default(cuid())
  taskId         String
  fromUserId     String   // Who it was reassigned from
  toUserId       String   // Who it was reassigned to
  scheduledTaskId String? // The specific scheduled instance (if applicable)
  createdAt      DateTime @default(now())

  task     Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  fromUser User @relation("ReassignedFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User @relation("ReassignedTo", fields: [toUserId], references: [id], onDelete: Cascade)

  @@index([taskId, toUserId])
  @@index([taskId, createdAt])
}
